import Data.Char (digitToInt)
import Data.List (unfoldr, transpose)
import qualified Utils as U

-- | Problem 1
-- [Multiples of 3 and 5](http://projecteuler.net/index.php?section=problems&id=1)
-- >> If we list all the natural numbers below 10 that are multiples of 3 or 5, 
-- >> we get 3, 5, 6 and 9. The sum of these multiples is 23. Find the sum of
-- >> all the multiples of 3 or 5 below 1000.
prob001 :: Int -> Int
prob001 n = sum . filter (\x -> mod x 3 == 0 || mod x 5 == 0) $ [1..(n-1)]


-- | Problem 2
-- [Even Fibonacci numbers](http://projecteuler.net/index.php?section=problems&id=2)
-- Each new term in the Fibonacci sequence is generated by adding the 
-- previous two terms. By starting with 1 and 2, the first 10 terms will be: 
-- 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ... By considering the terms in 
-- the Fibonacci sequence whose values do not exceed four million, 
-- find the sum of the even-valued terms.

prob002 :: Int
prob002 = sum $ filter even $ takeWhile (< 4000000) $ U.fibonacciSeq


-- | Problem 3
-- [Largest prime factor](http://projecteuler.net/index.php?section=problems&id=3)
-- The prime factors of 13195 are 5, 7, 13 and 29. 
-- What is the largest prime factor of the number 600851475143 ?

prob003 :: Int
prob003 = fst . last . U.factorInteger $ 600851475143


-- | Problem 4
-- [Largest palindrome product](http://projecteuler.net/index.php?section=problems&id=4)
-- A palindromic number reads the same both ways. The largest palindrome made
-- from the product of two 2-digit numbers is 9009 = 91 x 99. 
-- Find the largest palindrome made from the product of two 3-digit numbers.
prob004 :: Int
prob004 = maximum [ k | i <- [900..999], j <- [i..999], let k = i * j, U.isPalindrome k ]


-- | Problem 5
-- [Smallest multiple](http://projecteuler.net/index.php?section=problems&id=5)
-- 2520 is the smallest number that can be divided by each of the numbers 
-- from 1 to 10 without any remainder. What is the smallest positive number
-- that is evenly divisible by all of the numbers from 1 to 20?
prob005 :: Int
prob005 = foldr lcm 1 [1..20]


-- | Problem 6
-- [Sum square difference](http://projecteuler.net/index.php?section=problems&id=6)
-- The sum of the squares of the first ten natural numbers is,
-- 1^2 + 2^2 + ... + 10^2 = 385
-- The square of the sum of the first ten natural numbers is,
-- (1+2+ ... +10)^2 = 55^2 = 3025
-- Hence the difference between the sum of the squares of the first 
-- ten natural numbers and the square of the sum is 3025 - 385 = 2640. 
-- Find the difference between the sum of the squares of the first 
-- one hundred natural numbers and the square of the sum.
diffSumSquared :: Int -> Int
diffSumSquared n = simpleSum^2 - squaredSum
    where simpleSum  = (n * (n + 1)) `div` 2
          squaredSum = (n * (n + 1) * (2 * n + 1)) `div` 6

prob006 :: Int
prob006 = diffSumSquared 100


-- | Problem 7
-- [10001st prime](http://projecteuler.net/index.php?section=problems&id=7)
-- By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, 
-- we can see that the 6th prime is 13. What is the 10001st prime number?
prob007 :: Int
prob007 = last $ U.primes 10001


-- | Problem 8
-- [Largest product in a series](http://projecteuler.net/index.php?section=problems&id=8)
-- Find the greatest product of five consecutive digits in the 1000-digit number.

-- | partition n d xs generates sublist of 
-- >>> partition 4 2 [1..7]
-- [[1,2,3,4],[3,4,5,6]]
partition :: Int -> Int -> [a] -> [[a]]
partition n d xs = helper (length xs) xs
  where helper l xs
          | l < n     = []
          | otherwise = take n xs : helper (l-d) (drop d xs)

prod :: Num a => [a] -> a
prod = foldr (*) 1

prob008 :: Int
prob008 = maximum . map (prod . (map digitToInt)) . partition 5 1 $ s
    where s = "7316717653133062491922511967442657474235534919493496983520312774506326239578318016984801869478851843858615607891129494954595017379583319528532088055111254069874715852386305071569329096329522744304355766896648950445244523161731856403098711121722383113622298934233803081353362766142828064444866452387493035890729629049156044077239071381051585930796086670172427121883998797908792274921901699720888093776657273330010533678812202354218097512545405947522435258490771167055601360483958644670632441572215539753697817977846174064955149290862569321978468622482839722413756570560574902614079729686524145351004748216637048440319989000889524345065854122758866688116427171479924442928230863465674813919123162824586178664583591245665294765456828489128831426076900422421902267105562632111110937054421750694165896040807198403850962455444362981230987879927244284909188845801561660979191338754992005240636899125607176060588611646710940507754100225698315520005593572972571636269561882670428252483600823257530420752963450"




-- | Problem 9
-- [Special Pythagorean triplet](http://projecteuler.net/index.php?section=problems&id=9)
-- A Pythagorean triplet is a set of three natural numbers, a, b, c, for which a^2 + b^2 = c^2.
-- For example, 3^2 + 4^2 = 9+16 = 25 = 5^2.
-- There exists exactly one Pythagorean triplet for which a+b+c=1000. Find the product a b c.
prob009 :: Int
prob009 = head [a * b * c | a <- [1..333], 
                            let (b, m) = (1000 * (500 - a)) `divMod` (1000 - a),
                            m == 0,
                            let c = 1000 - a - b,
                            a^2 + b^2 == c^2 ]


-- | Problem 10
-- [Summation of primes](http://projecteuler.net/index.php?section=problems&id=10)
-- The sum of the primes below 10 is 2+3+5+7=17. 
-- Find the sum of all the primes below two million.
prob010 :: Int
prob010 = sum $ U.primesTo 2000000


-- | Problem 11
-- [Largest product in a grid](http://projecteuler.net/index.php?section=problems&id=11)
-- In the 20 20 grid below, four numbers along a diagonal line have been marked in red.
partitionMatrix :: (Int, Int) -> (Int, Int) -> [[a]] -> [[[a]]]
partitionMatrix (nRow, nCol) (dRow, dCol) = 
    map transpose . concat . map (partition nCol dCol . transpose) . partition nRow dRow

diagonal :: [[a]] -> [a]
diagonal [[]]        = []
diagonal [(x:_)]     = [x]
diagonal ((x:_):xss) = x : diagonal (map tail xss)

prob011 :: Int
prob011 = maximum [ysHorizontal, ysVertiacal, ysDiagonal, ysAntigonal]
  where s = "\
             \08 02 22 97 38 15 00 40 00 75 04 05 07 78 52 12 50 77 91 08 \
             \49 49 99 40 17 81 18 57 60 87 17 40 98 43 69 48 04 56 62 00 \
             \81 49 31 73 55 79 14 29 93 71 40 67 53 88 30 03 49 13 36 65 \
             \52 70 95 23 04 60 11 42 69 24 68 56 01 32 56 71 37 02 36 91 \
             \22 31 16 71 51 67 63 89 41 92 36 54 22 40 40 28 66 33 13 80 \
             \24 47 32 60 99 03 45 02 44 75 33 53 78 36 84 20 35 17 12 50 \
             \32 98 81 28 64 23 67 10 26 38 40 67 59 54 70 66 18 38 64 70 \
             \67 26 20 68 02 62 12 20 95 63 94 39 63 08 40 91 66 49 94 21 \
             \24 55 58 05 66 73 99 26 97 17 78 78 96 83 14 88 34 89 63 72 \
             \21 36 23 09 75 00 76 44 20 45 35 14 00 61 33 97 34 31 33 95 \
             \78 17 53 28 22 75 31 67 15 94 03 80 04 62 16 14 09 53 56 92 \
             \16 39 05 42 96 35 31 47 55 58 88 24 00 17 54 24 36 29 85 57 \
             \86 56 00 48 35 71 89 07 05 44 44 37 44 60 21 58 51 54 17 58 \
             \19 80 81 68 05 94 47 69 28 73 92 13 86 52 17 77 04 89 55 40 \
             \04 52 08 83 97 35 99 16 07 97 57 32 16 26 26 79 33 27 98 66 \
             \88 36 68 87 57 62 20 72 03 46 33 67 46 55 12 32 63 93 53 69 \
             \04 42 16 73 38 25 39 11 24 94 72 18 08 46 29 32 40 62 76 36 \
             \20 69 36 41 72 30 23 88 34 62 99 69 82 67 59 85 74 04 36 16 \
             \20 73 35 29 78 31 90 01 74 31 49 71 48 86 81 16 23 57 05 54 \
             \01 70 54 71 83 51 54 69 16 92 33 48 61 43 52 01 89 19 67 48 \
             \"
        xss = partition 20 20 $ map read $ U.splitOn ' ' s
        ysHorizontal = maximum . map prod . concatMap (partition 4 1) $ xss
        ysVertiacal = maximum . map prod . concatMap (partition 4 1) . transpose $ xss
        ysDiagonal = maximum . map (prod . diagonal) . partitionMatrix (4, 4) (1, 1) $ xss
        ysAntigonal = maximum . map (prod . diagonal) . partitionMatrix (4, 4) (1, 1) . reverse $ xss


-- Problem 12 
-- [Highly divisible triangular number](http://projecteuler.net/index.php?section=problems&id=12)

triangleNumber :: Int -> Int
triangleNumber n = n * (n + 1) `div` 2

prob012 :: Int
prob012 = head $ filter ((> 500) . length . U.divisors) $ map triangleNumber [1..]


-- | Problem 13
-- [Large sum](http://projecteuler.net/index.php?section=problems&id=13)

-- | Problem 14
-- [Longest Collatz sequence](http://projecteuler.net/index.php?section=problems&id=14)
collatz :: Int -> Int
collatz n
  | even n    = n `div` 2
  | otherwise = 3 * n + 1

collatzLen :: Int -> Int
collatzLen 1 = 0
collatzLen n = 1 + collatzLen (collatz n)

prob014 :: Int
prob014 = snd $ maximum [ (collatzLen i, i) | i <- [1..1000000-1] ]


-- Problem 15: [Lattice paths](http://projecteuler.net/index.php?section=problems&id=15)
prob015 :: Int
prob015 = U.binomial 40 20

-- Problem 16
-- (http://projecteuler.net/index.php?section=problems&id=13)

main :: IO ()
main = print $ prob014
